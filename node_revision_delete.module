<?php

/**
 * @file
 * Contains node_revision_delete.module.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\Core\Url;
use Drupal\Core\Link;
use Drupal\Core\Form\FormStateInterface;

// The maximun months for the 'When to delete' config.
define('NODE_REVISION_DELETE_WHEN_TO_DELETE_MAXIMUN_MONTHS', 12);
define('NODE_REVISION_DELETE_MINIMUN_AGE_TO_DELETE_MAXIMUN_MONTHS', 12);

/**
 * Implements hook_help().
 */
function node_revision_delete_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help.
    case 'help.page.node_revision_delete':

      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('The Node Revision Delete module allows you to manage the revisions of the Node according to your choice. It helps you to keep the specific number of revisions for the node. This module provides you the flexibility for applying the revision delete for the specific content type and run it on the specific time.') . '</p>';
      $output .= '<h3>' . t('Uses') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>' . t('Configuring the module') . '</dt>';
      $output .= '<dd>' . t('You can manage your settings from the @config-page page. For this you need the <em>Administer node revision delete settings</em> permission.', array('@config-page' => Link::fromTextAndUrl('Node Revision Delete Administration Page', Url::fromRoute('node_revision_delete.admin_settings'))->toString())) . '</dd>';
      $output .= '</dl>';
      $output .= '<h3>' . t('Drush commands') . '</h3>';
      $output .= '<dl>';
      $output .= '<dt>drush node-revision-delete</dt>';
      $output .= '<dd>' . t('Deletes old node revisions for a given content type.') . '</dd>';
      $output .= '</dl>';

      return $output;

    case 'node_revision_delete.admin_settings':
      $output = '';
      $output .= '<p>' . t("To allow Node Revision Delete to act upon a certain content type, you should navigate to the desired content type's edit page via:") . '</p>';
      $output .= '<p><em>' . t('Administration » Structure » Content types » [Content type name]') . '</em></p>';
      $output .= '<p>' . t("Under the Publishing Options tab, enable 'Create new revision' and 'Limit the amount of revisions for this content type' checkboxes. Change the Maximum number of revisions to keep, if you need to, and finally, save your changes clicking in the Save content type button.") . '</p>';

      return $output;
  }
}

/**
 * Implements hook_preprocess_page().
 */
function node_revision_delete_preprocess_page(&$variables) {
  $route_name = \Drupal::routeMatch()->getRouteName();
  switch ($route_name) {
    // Adding a css file to the Node Revision Delete Administration Page.
    case 'node_revision_delete.admin_settings':
      $variables['#attached']['library'][] = 'node_revision_delete/admin_settings';
      break;
  }
}

/**
 * Implements hook_form_BASE_FORM_ID_alter().
 */
function node_revision_delete_form_node_type_form_alter(&$form, FormStateInterface &$form_state, $form_id) {
  // Geting the config.
  $config = \Drupal::config('node_revision_delete.settings');
  // Getting the content types to track variable.
  $node_revision_delete_track = $config->get('node_revision_delete_track');
  // Getting the content type machine name from the actual form.
  $content_type = $form_state->getFormObject()->getEntity()->id();
  // Looking if the config exists for the content type.
  if (isset($node_revision_delete_track[$content_type])) {
    $track = TRUE;
    $revisions_to_keep = $node_revision_delete_track[$content_type]['revisions_to_keep'];
    $when_to_delete = $node_revision_delete_track[$content_type]['when_to_delete'];
    $minimun_age_to_delete = $node_revision_delete_track[$content_type]['minimun_age_to_delete'];
  }
  else {
    $track = FALSE;
    $revisions_to_keep = 1;
    $when_to_delete = 0;
    $minimun_age_to_delete = 0;
  }
  // Element to track the content type.
  $form['workflow']['node_revision_delete_track'] = [
    '#type' => 'checkbox',
    '#title' => t('Limit the amount of revisions for this content type'),
    '#default_value' => $track,
    '#attached' => [
      'library' => [
        'node_revision_delete/content_types',
        'node_revision_delete/admin_settings',
      ],
    ],
  ];
  // Element for the maximun number of revisions to keep.
  $form['workflow']['node_revision_delete_revisions_to_keep'] = [
    '#type' => 'number',
    '#title' => t('Maximum number of revisions to keep'),
    '#description' => t('Oldest revisions will be deleted when the total amount surpases this value. Set it to 1 to remove all revisions.'),
    '#default_value' => $revisions_to_keep,
    '#min' => 1,
    '#states' => [
      // Hide the settings when the cancel notify checkbox is disabled.
      'visible' => [
        ':input[name="node_revision_delete_track"]' => array('checked' => TRUE),
      ],
    ],
  ];

  // Available options for node_revision_delete_when_to_delete variable.
  $options_node_revision_delete_when_to_delete[0] = t('Always');
  for ($i = 1; $i <= NODE_REVISION_DELETE_WHEN_TO_DELETE_MAXIMUN_MONTHS; $i++) {
    $singular = 'After @number month of inactivity';
    $plural = 'After @number months of inactivity';
    $options_node_revision_delete_when_to_delete[$i] = \Drupal::translation()->formatPlural($i, $singular, $plural, ['@number' => $i]);
  }
  // Element to know when to delete the revisions.
  $form['workflow']['node_revision_delete_when_to_delete'] = [
    '#type' => 'select',
    '#title' => t('When to delete'),
    '#description' => t('If the current revision is not older than specified here, its older revisions will not be deleted, even if they are old enough. If set to "Always", older revisions will be deleted regardless of the age of the current revision.'),
    '#options' => $options_node_revision_delete_when_to_delete,
    '#size' => 1,
    '#default_value' => $when_to_delete,
    '#states' => [
      // Hide the settings when the cancel notify checkbox is disabled.
      'visible' => [
        ':input[name="node_revision_delete_track"]' => array('checked' => TRUE),
      ],
    ],
  ];

  // Available options for node_revision_delete_minimun_age_to_delete.
  $options_node_revision_delete_minimun_age_to_delete[0] = t('None');
  for ($i = 1; $i <= NODE_REVISION_DELETE_MINIMUN_AGE_TO_DELETE_MAXIMUN_MONTHS; $i++) {
    $singular = '@number month';
    $plural = '@number months';
    $options_node_revision_delete_minimun_age_to_delete[$i] = \Drupal::translation()->formatPlural($i, $singular, $plural, ['@number' => $i]);
  }
  // Element to know when to delete the revisions.
  $form['workflow']['node_revision_delete_minimun_age_to_delete'] = [
    '#type' => 'select',
    '#title' => t('Minimum age of revision to delete'),
    '#description' => t('Revisions older of this age will be deleted. "If the Maximum number of revisions to keep" is greater than 1 we will keep this number of revision after the "Minimum age of revision to delete" including the revision that have the selected age.'),
    '#options' => $options_node_revision_delete_minimun_age_to_delete,
    '#size' => 1,
    '#default_value' => $minimun_age_to_delete,
    '#states' => [
      // Hide the settings when the cancel notify checkbox is disabled.
      'visible' => [
        ':input[name="node_revision_delete_track"]' => array('checked' => TRUE),
      ],
    ],
  ];

  // If we are creating the content type. Putting the custom submit handler
  // first to use the Entity->isNew() function, if the custom submit handler is
  // the last function called always the Entity is created first.
  array_unshift($form['actions']['save_continue']['#submit'], '_node_revision_delete_form_node_type_submit');
  // If we are editing the content type. Putting the custom submit handler
  // first to use the Entity->isNew() function, if the custom submit handler is
  // the last function called always the Entity is created first.
  array_unshift($form['actions']['submit']['#submit'], '_node_revision_delete_form_node_type_submit');
}

/**
 * Custom submit handler to save the configuration variables.
 *
 * @param array $form
 *   The form element.
 * @param FormStateInterface $form_state
 *   The form state.
 */
function _node_revision_delete_form_node_type_submit(array &$form, FormStateInterface $form_state) {
  // Getting the form values.
  $track = $form_state->getValue('node_revision_delete_track');
  $revisions_to_keep = $form_state->getValue('node_revision_delete_revisions_to_keep');
  $when_to_delete = $form_state->getValue('node_revision_delete_when_to_delete');
  $minimun_age_to_delete = $form_state->getValue('node_revision_delete_minimun_age_to_delete');
  // Getting the content type machine name.
  $content_type = $form_state->getFormObject()->getEntity()->id();
  // If we will track the content type.
  if ($track) {
    // Saving the values in the config.
    _node_revision_delete_save_content_type_config($content_type, $revisions_to_keep, $when_to_delete, $minimun_age_to_delete);
  }
  // If we are not tranking the content type and it exists (is not new)
  // we need to delete the his config.
  elseif (!$form_state->getFormObject()->getEntity()->isNew()) {
    // Deleting the value from the config.
    _node_revision_delete_delete_content_type_config($content_type);
  }
}

/**
 * Save the content type config variable.
 *
 * @param string $content_type
 *   Content type machine name.
 * @param int $revisions_to_keep
 *   Maximun number of revisions to keep.
 * @param int $when_to_delete
 *   Number of inactivity months to wait for delete a revision.
 * @param int $minimun_age_to_delete
 *   Minimum age in months of revision to delete.
 */
function _node_revision_delete_save_content_type_config($content_type, $revisions_to_keep, $when_to_delete, $minimun_age_to_delete) {
  // Getting the config file.
  $config = \Drupal::service('config.factory')->getEditable('node_revision_delete.settings');
  // Getting the variables with the content types configuration.
  $node_revision_delete_track = $config->get('node_revision_delete_track');
  // Creating the content type info.
  $content_type_info = [
    'revisions_to_keep' => $revisions_to_keep,
    'when_to_delete' => $when_to_delete,
    'minimun_age_to_delete' => $minimun_age_to_delete,
  ];
  // Adding the info into te array.
  $node_revision_delete_track[$content_type] = $content_type_info;
  // Saving the values in the config.
  $config->set('node_revision_delete_track', $node_revision_delete_track)->save();
}

/**
 * Implements hook_form_FORM_ID_alter().
 */
function node_revision_delete_form_node_type_delete_form_alter(&$form, FormStateInterface &$form_state, $form_id) {
  // If we are deleting a content type.
  $form['actions']['submit']['#submit'][] = '_node_revision_delete_form_node_type_delete';
}

/**
 * Custom submit handler to delete the configuration variables.
 *
 * @param array $form
 *   The form element.
 * @param FormStateInterface $form_state
 *   The form state.
 */
function _node_revision_delete_form_node_type_delete(array &$form, FormStateInterface $form_state) {
  // Getting the content type machine name.
  $content_type = $form_state->getFormObject()->getEntity()->id();
  // Deleting the value from the config.
  _node_revision_delete_delete_content_type_config($content_type);
}

/**
 * Delete the content type config variable.
 *
 * @param string $content_type
 *   Content type machine name.
 *
 * @return bool
 *   Return TRUE if the content type config was deleted or FALSE if not exists.
 */
function _node_revision_delete_delete_content_type_config($content_type) {
  // Getting the config file.
  $config = \Drupal::service('config.factory')->getEditable('node_revision_delete.settings');
  // Getting the variables with the content types configuration.
  $node_revision_delete_track = $config->get('node_revision_delete_track');
  // Checking if the config exists.
  if (isset($node_revision_delete_track[$content_type])) {
    // Deleting the value from the array.
    unset($node_revision_delete_track[$content_type]);
    // Saving the values in the config.
    $config->set('node_revision_delete_track', $node_revision_delete_track)->save();
    return TRUE;
  }
  return FALSE;
}

/**
 * Return the list of candidate nodes for node revision delete.
 *
 * @param string $content_type
 *   Content type machine name.
 * @param int $revisions_to_keep
 *   Maximum number of revisions to keep.
 *
 * @return array
 *   Array of nids.
 */
function _node_revision_delete_candidates($content_type, $revisions_to_keep) {
  $connection = \Drupal::service('database');
  // Array with sustitution values.
  $array = [
    ':content_type' => $content_type,
    ':revisions_to_keep' => $revisions_to_keep,
  ];

  $result = $connection->query('SELECT n.nid, count(n.nid) as total
                     FROM node n
                     INNER JOIN node_revision r ON r.nid = n.nid
                     WHERE n.type = :content_type
                     GROUP BY n.nid
                     HAVING count(n.nid) > :revisions_to_keep', $array);
  return $result->fetchCol();
}

/**
 * Implements hook_library_info_alter().
 */
function node_revision_delete_library_info_alter(&$libraries, $extension) {
  // Deleting the library because we have our own version.
  // Maybe this cannot be longer needed once https://www.drupal.org/node/2871619
  // will be fixed.
  if ($extension == 'node' && isset($libraries['drupal.content_types'])) {
    unset($libraries['drupal.content_types']);
  }
}
